---
title: "Qiankun 沙箱技术浅析"
date: "2022-02-22"
---

# WIP

最近因工作需要调研了一下 [Qiankun/乾坤](https://qiankun.umijs.org/zh) 微前端框架的<Note label="沙箱机制">指的是子应用与其他子应用或主应用之间的运行环境相互隔离，这样可以更好的避免 CSS/JS 等运行时相互污染的问题。</Note>实现思路。
Qiankun 在其主页上声称，它是“简单、完备、生产可用”的。它的目标，是让一个前端应用在不做专门适配的情况下就可以注册为子应用，嵌入到一个微前端应用的基座容器中正常渲染。

将任意的 Web 应用直接作为微前端子应用使用有一些技术难点需要攻克，比如：

- JS 全局变量 `window` 的隔离
- CSS 样式的隔离
- 子应用的路由隔离，[可参考这里](https://zhuanlan.zhihu.com/p/355419817)
- 切换应用时需要把子应用的副作用、内存泄漏等清理掉

在框架的提供的外部 API 与内部具体实现的权衡中，Qiankun 试图把沙箱的实现复杂度封装在框架内部，以便于开发者可以把任务中心放在业务实现上，尽量减轻沙箱机制对于开发者造成的心智负担。

一般来说，一个普通的 Web 应用没有考虑到会被作为微前端子应用使用，自然地开发者在开发时也不会对全局变量的使用有任何顾虑。以 Qiankun 的愿景来看，它不希望子应用那边在源码级别做过多的改动，那么就需要在运行时多做一点文章。

## 初探运行时沙箱实现原理

iframe 是一种特性完备的浏览器沙箱。[但 Qiankun 设计者认为](https://zhuanlan.zhihu.com/p/451425684)，iframe 会造成一些体验上的问题，因此从最开始就排除了将 iframe 作为微前端方案的核心。

根据隔离场景，我们需要有 JS 沙箱与 CSS 沙箱两种机制。

### JS 沙箱

JS 沙箱目前还没有主流浏览器支持的成熟方案。虽然 TC39 的 [ShadowRealm API](https://tc39.es/proposal-shadowrealm/) 提案未来可期，社区中有一些 Polyfill 实现，不过它目前还处于很早期的草案阶段，很难作为生产环境方案使用。

调研前，以我对 Qiankun 粗浅的理解，它的 JS 沙箱是基于 ES 的 Proxy 实现的。在初始化后，Qiankun 会为对于任意一个子应用实例化专用的 Proxy 实例，这个实例会代理到 `window` 上；在运行时，它会通过"**某种方式**"将子应用 js 模块对 `window` 对象的访问重新定向到 Proxy 实例上。

Qiankun 使用了一种巧妙（括弧 Hack）的方式在运行时对子应用模块中全局变量访问进行重定向。

### CSS 隔离

对于 CSS 来说，Qiankun 的主要维护者在 [Qiankun 快问快答](https://zhuanlan.zhihu.com/p/451425684) 中推荐应用本身在构建时就做好样式隔离，这样它被作为子应用使用时天然就具备了隔离特性。
不过 Qiankun 还是在运行时提供了的样式隔离机制，其原理是拦截子应用样式表，将所有 class 加上一个特殊的前缀，避免冲突；同时在新版本中，它还支持以 Shadow DOM 的模式隔离子应用的 CSS。

另外，一些基于运行时的 CSS-in-JS 框架，如 Emotion、styled-components、或是 Webpack 的 style-loader 会把样式动态的向根部页面的 HEAD 标签插入 STYLE。这里有两个问题：

- 假如子应用被隔离在 shadow dom 中时，由于 shadow dom 的隔离特性，样式标签需要加入相应的 shadow root 中，而不是根部模板 HEAD 中
- 子应用卸载时，需要清理子应用动态插入的样式标签

## 浅析 Qiankun 运行时替换 `window` 机制

https://github.com/kuitos/import-html-entry

Scan html, extract entry assets. For each JS, fetch it, replace window with proxy etc and then eval it.

## 未完成 ...
